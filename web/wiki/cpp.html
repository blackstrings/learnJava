<html>
<head>
	<title></title>
	<script data-main="js/mainWiki" src="js/lib/require.js"></script>
	<script>
		//if you call it explicitly like this, you have to call the common configs again so your file path will stay relative
		require(['./commonWiki'], function (common) {
			require(["jquery", "app/wikiUtils"], function($, utils){
				$(function() {
					utils.setMainWebTitle("C++");
				});
			});
		});
	</script>
</head>

<body>

<div id="contents">
	<section>
		<h1>C++</h1>
		<p>A scripting language we use for some of our legacy apps (Fence, Polebarn, Garage).</p>
		
		<section>
			<h1>Requirements</h1>
			<p> <a href="vs6.html">Visual Studio 6</a> is the IDE for the old C++ apps.</p>
			<p>To build these app we have to manually put together the build. Unlike our Java apps we can use Maven to package our app.</p>
			<p>
			The reason we do not use Visual Studio 7 or higher is because our legacy C++ apps is using the ZAPP framework for buttons and 3D rendering, which ZAPP in return does not work so well with the newer versions of Visual Studio.
			</p>
		</section>
		
		<section>
			<h1>Major Difference from Java Apps</h1>
			<ul>
				<li><a href="javacpp.html" target="_blank">Differences</a></li>
				<li><a href="environment.html">Environment Pointing</a></li>
				<li><a href="memcache.html">MemCache</a> is used to cache data for C app data to make it load faster</li>
				<li>All our c++ apps should be located under C:/mes folder to function properly</li>
				<li>C++ is a middle level programming language vs the high level language Java</li>
				<li>You have to manage your own garbage collection</li>
				<li>Uses pointers</li>
				<li>Define methods and variables in header files (fileName.h)</li>
				<li>Implement the methods in .cpp files</li>
			</ul>
			
		</section>
		
		<section>
			<h1>Intro</h1>
			<section class="box">
				<h2>#includes</h2>
				<p>To import or include Libraries or dll files that have classes in them.
				Similar to java's import. They go at the top of the files. use quotes for custom libraries not in default c package</p>
<pre>
//cout
#include &lt;iostream&gt;
//string class
#include &lt;string&gt;
//exit_success
#include &lt;cstlib&gt; 
//your custom library
#include "CustLib"
</pre>
			</section>
			<section class="box">
				<h2>Main Method</h2>
				<p>Like all langauage, there is a method that initiates the start of the entire app called the main method</p>
				<p>The main methed always returns a 0. It is optional to omit arguments. If you wish to replace the return 0 with 
				EXIT_SUCCESS, then include the cstlib library.</p>
<pre>
#include &lt;iostream&gt;
int main(){
	cout << "hello world" << endl;
	return 0;
}
</pre>
			</section>
			
			<section class="box">
				<h2>.cpp .h .dll</h2>
				<p>.h are the header files (like interface in java) where the accessors, methods and fields are defined</p>
				<p>.cpp is the implementation file where methods/fields are more defined</p>
				<p>.dll are the libraries created when you build/compile your c++ app. Their purpose is for code reuse so you can include
				the new dll into another c++ app.
				All the classes gets converted into .asm or assembly language at build time and are put into the .dll file.</p>
			</section>
			
			<section class="box">
				<h2>Class Header</h2>
				<p>
				If in seperate file, make sure you define your methods above the main method before you can use it inside the main method.
				Or Include the header.</p>
<pre>
//define
#ifndef Ball.h
#define Ball.h
class Ball{
public:
	Ball();
	~Ball();
	void roll();
	int getId();
private:
	int id;
}
#endif
</pre>
				</p>
			</section>
			
			<section class="box">
				<h2>#ifndef </h2>
				<p>We put this in the header .h files</p>
				<p>It basically checks itself when other classes include it</p>
				<p>Used to prevent multiple includes of the same .h file. This is useful when working in large projects</p>
				</p>After the file is included, other files that call the same .h file, it will not allow itself to be added again</p>
			</section>
			
			<section class="box">
				<h2>forward declare</h2>
				<p>Always forward declare what you can and avoid include if not needed</p>
				<p>use forward in class A, if class A contains B pointer or reference ex: B* ptr;</p>
				<p>use forward in class A, if one or more methods has B obj/pointer/reference</p>
<pre>
// ClassA.h
#ifndef ....

//forward declare
class B;
class C;

#include ...

Class A {
   B* bPtr;
   void m1(B* bPtr);
   //B b; this would mean you need to use #include B
}
</pre>
			</section>
			
			<section class="box">
				<h2>Circular dependencies</h2>
				<p>when two or more class depend on each other through pointers. ClassA depends on ClassB. ClassB depends on ClassA. The solution is forward dependency
				 and not use include</p>
				<p>It is a design flaw and is impossible to include each class as regular objects in each other</p>
<pre>
//impossible and a design flaw
ClassA {
   B b;
}
ClassB {
   A a;
}
//solution
ClassA {
  B* ptr;
}
ClassB {
  A* ptr;
}
</pre>
			</section>
			
		</section>
		
		<section>
			<h1>Best Practices</h1>
			<section class="box">
				<h2>Pointers</h2>
				<p>Avoid the use of pointers whenever possible. Usually the use is when you need to traverse through a list</p>
			</section>
			<section class="box">
				<h2>Methods</h2>
				<p>For non-primitive type/objects Pass by reference is prefered than by pointers. This involves the & symbol next to the reference name in the args</p>
<pre>
void eat(Fruit &someFruit){
	...
}
Fruit fruit;
eat(fruit);
</pre>
				<p>For primitive types, c++ passes by value, so the implementation is the same in java</p>
<pre>
int addFive(int num){
	return num += 5;
}
</pre>
			</section>
			<section class="box">
				<h2>Returning objects</h2>
				<p>Avoid the use of creating a new obj inside the local scope. 
				example below, Although b will be destroyed, a copy of b is returned back.</p>
<pre>
//best practie way to return
Ball Class1::getBall(){
	Ball b;
	return b;
}
</pre>
			</section>
		</section>
			
		<section>
			<h1>Namespaces</h1>
			<section class="box">
				<h2>Creating</h2>
				<p>Used to prevent conflicts.<a href="http://stackoverflow.com/questions/41590/how-do-you-properly-use-namespaces-in-c"> More read</a></p>
<pre>
namespace Lao{
   class Dog{
      Dog::Dog();
   };
}
</pre>
			</section>
			
			<section class="box">
				<h2>Nested</h2>
				<p>Declaring nested namespace</p>
<pre>
namespace Lao::General{
   class Dog{
      Dog::Dog();
   };
}
</pre>
			</section>
			
			
			<section class="box">
				<h2>Compositing</h2>
				<p>Combinging/Merging A and B namesspace in C</p>
<pre>
namespace A{
   void AA();
}
namespace B{
   void BB();
}
namesspace C{
   using namespace A;
   using namespace B;
}
void main(){
   C::BB();
   C::AA();
}
</pre>
			</section>
			
			<section class="box">
				<h2>Alias Namespace</h2>
				<p>Where a namespace is too long, you can shorten it</p>
<pre>
namespace Lao::General::Utils{
   class Dog{
      Dog::Dog();
   };
}
int main(){
   namespace Short =  Lao::General::Utils;
   Short::Dog d;
}
</pre>
			</section>
			
			<section class="box">
				<h2>using vs using namespace</h2>
				<p>avoid the use of the full name space something like: using namespace std; as it imports all the fields in std and becomes more clutter.</p>
				<p>Instead import namespace field names inside functions as you need only like this:</p>
<pre>
void met(){
   using std::string;
   string str = "hi";
   std::cout << str << endl;
}
</pre>
				
			</section>
		</section>
		
		<section>
			<h1>Instantiation</h1>
			<section class="box">
				<h2>Stack</h2>
				<p><a href="http://stackoverflow.com/questions/333443/c-object-instantiation">Good Read</a></p>
				<p>The most prefered way is to create objects on the stack and let the object reallocate memory automatically
				 through it's destructor without you having to manage and remember manually to release memory back when the object is no
				  longer in use. Stack is size limited so very large objects will have to be created on the heap.
				  </p>
				  <p>
				 Stack memory means when the variable is no longer in use or referenced, the memory will auto reallocate itself.
				When you don't use the "new" keyword, you create memory on the stack which is what you want to do most of the time,
				so you don't have to handle manually releasing memory back. 
				Local variables created without "new" are on the stack memory. Or when the method returns, the local variables that were
				created are cleared.</p>
<pre>
int num = 5;
Dog d;
Dog d(55);
</pre>
				<p>When you create objects this way, you don't really use a pointer, as a pointer are use to point to memory on the heap.
				Besides, you want to avoid referencing or using pointers to ref a local memory on the stack, 
				as the stack constantly is reallocating memory and changing.
				</p>
			</section>
			<section class="box">
				<h2>Heap</h2>
				<p>Heap is dynamic memory allocation that occurs on the heap memory. It stays there permanently until deleted.
				Everytime you use the "new" keyword you create memory on the heap. IMPORTANT RULE: Treat heap as a last resort thing when 
					you can't use the stack, such as for very large obj, use the heap.</p>
				<p>You are responsible to delete any object you
				 create to reallocatre memory back. if you don't the memory will stay there forever, until the processor
				  ends or restarts.</p>
<pre>
Dog* p1 = new Dog;
delete p1;
</pre>
				<p>If you go this route using the new keyword, make use of smart pointers like the auto_ptr to manage the life time of the object</p>
				<p>Smart pointers usually have a counter, and keeps track of the # of objects that reference it. When the counter reaches zero,
				it is how it will know that no other objects are referencing it anymore, so the object knows when to delete itself.
				</p>
			</section>
			
		</section>
		
		<section>
			<h1>Methods Functions</h1>
			<section class="box">
				<h2>Add Class in Main class</h2>
				<p>
				Make sure you define your methods above the main method before you can use it inside the main method.
				You cn implement the methods before or below the main method after you define it.
<pre>
//define
class Ball{
public:
	Ball();
	~Ball();
	void roll();
	int getId();
private:
	int id;
}
</pre>
				</p>
			</section>
			<section class="box">
				<h2>Arguments</h2>
				<p>The idea is to avoid using pointers whenever possible. Becareful to avoid using the antiPattern if you do use pointers.
				 That is to not create new objects just so you can use pointers.</p>
<pre>
void eat(Fruit* f);

//antiPattern
Fruit* f = new Fruit;
eat(f);
delete f;

//prefered
Fruit fruit;
eat(&fruit);
</pre>

				<p>A better way is to use address</p>
<pre>
void eat(Apple& a);
Apple a;
eat(a);
</pre>
			</section>
			
			
		</section>
		
		<section>
			<h1>Printing To Console</h1>
			<section class="box">
				<h2>Message box</h2>
				<p>MessageBox(NULL, "meow", "Roof", MB_OK);</p>
			</section>
			<section class="box">
				<h2>cout</h2>
				<p>#include &lt;iostream&gt; library to use cout</p>
				<p>cout &lt;&lt; "hello world" &lt;&lt; endl;</p>
			</section>
			<section class="box">
				<h2>printf (best way)</h2>
				<p>This method is from C not C++, printf(), but you can use it in C++</p>
				<p>printf("hello %s. Your age is %d", name, 55)</p>
			</section>
		</section>
		
		<section>
			<h1>Accessing class fields and methods</h1>
			<section class="box">
				<h2>Dot method</h2>
				<p>When working with instance of a class.</p>
<pre>
//create dog
Dog d;
//access method
d.bark();
//access field
int age = d.age;
</pre>
				<p>More details <a href="http://stackoverflow.com/questions/11902791/what-is-the-difference-between-and-in-c">Here</a></p>
			</section>
			
			<section class="box">
				<h2>-&gt; method</h2>
				<p>When working with pointers</p>
<pre>
//create pointer
Dog * dogPtr = new Dog();
//access method
dogPtr->bark();
//access field
int age = dogPtr->age;
</pre>
				<p>More details <a href="http://stackoverflow.com/questions/11902791/what-is-the-difference-between-and-in-c">Here</a></p>
			</section>
			
			<section class="box">
				<h2>:: method</h2>
				<p>When working with Static classes</p>
<pre>
//access method
MyUtil::random();
//access field
int num = MyUtil::date;
</pre>
				<p>More details <a href="http://stackoverflow.com/questions/11902791/what-is-the-difference-between-and-in-c">Here</a></p>
			</section>
		</section>
		
		
		<section>
			<h1>Pointers</h1>
			<section class="box">
				<h2>Basic</h2>
				<p>Allow a variable to reference the address and value of another variable. 
				A pointers can change it's address by referencing another address.</p>
				<p>You can set an address to a pointer upon creation</p>
				<p>In C-Style, you use malloc instead of pointers to allocate memory</p>
<pre>
int * pointer1 = 99;
Dog * d = new Dog();	//must use new if initializing pointers this way with a class
</pre>
			</section>
			
			<section class="box">
				<h2>Get Value of Ptr</h2>
				<p>Put a * before the pointer name. This is called dereferencing a pointer.</p>
<pre>
int val = *intPtr;
//or
cout &lt;&lt; *intPtr;
</pre>
			</section>
			
			<section class="box">
				<h2>Set address</h2>
				<p>Put a * before the pointer name. This is called dereferencing a pointer.</p>
<pre>
int var = 99;

//p1 points to address of var
int * p1 = &var;

//p2 points to same address as p1
int * p2 = p1;

//same as above
int * p3;
p3 = p1;
</pre>
			</section>
			
			<section class="box">
				<h2>Const</h2>
				<p>Its purpose is to create read only pointers so change cannot be made or alter. 
				When used in method arguments, it is to prevent pointers from altering the value</p>
<pre>
//Readonly EX
int myNum = 5;
const int* p1 = &myNum;
//p1 cannot change value of myNum
</pre>
<pre>
//both are same
const int * p1;
int const * p2;
</pre>

				<p>
				a const after the * means the pointer itself is const
				</p>
<pre>
int * const p1;
//the pointer itself cannot change address
</pre>
				<p>Combining both const value and const pointers</p>
<pre>
const int * const p1;
</pre>	
			</section>
		</section>
		
		<section>
			<h1>Arrays [] Array []</h1>
			
			<section class="box">
				<h2>c-style Array</h2>
				<p>Unlike in java, with c-style array, You have to keep track of on your array size on your own into a variable.
				You cannot or will find the size of the array at runtime in c++ hard to do.(also not reliable once you start using pointers). 
				Hence std:vector is preferred over c-style array, as it does keep track of its size, so use vector instead as it works similar to
				java arrays.
				The use of vector far outweighs the old c-style array.
				</p>
<pre>
//c-style reg array
int dogSize = 5;
Dog dogs[5];
</pre>
				<p>You can also use this strategy at runtime to find the size for c-style array: </p>
<pre>
int newSize = sizeof(array)/sizeof(array[0]);
</pre>
			</section>
			
			<section class="box">
				<h2>c-style string</h2>
				<p>You can assign string like values when you initate an char array.
				Using the quotes, the \0 will be auto appended to null the end of the array.
				</p>
<pre>
char name[] = "Sam";
char name[5] = "Sam";
</pre>
				<p>Not using the quotes, you'll have to append the \0</p>
<pre>
char name[] = { 'S', 'a', 'm', '\0' }; 
</pre>
				<p>Once you initate the char array, you cannot simply assign new values like this</p>
<pre>
//error
name = "Kim";
//nor
name = { 'K', 'i', 'm', '\0' };
</pre>
				<p>To resolve this, use the std::strcpy(a,b). Note strcpy is only for c-style strings not c++.
				If the copy to array doesn't have enough memory, it'll still copy, just that you'll get wierd numbers
				 at the end of the array.</p>
<pre>
char newName[99];
strcpy(newName, name);
</pre>
				<p>If you are working with the actual string class, use the = operator instead.
				The string is dynamic and will grow automatically behind the scene to make memory for the new string</p>
<pre>
string name = "Jhon";
string name2;
name2 = name;
</pre>
			</section>
			
			<section class="box">
				<h2>Pointer Array</h2>
				<p>Use pointers to point to array</p>
<pre>
int* a = new int[4];
</pre>
			</section>
			
			<section class="box">
				<h2>New Array</h2>
				<p>use an array container instead of the c-style array.</p>
<pre>
#include &lt;array&gt;
array&lt;type_of_array, number_of_elements&gt; ref_name = {};
</pre>
				<p>You can also use this strategy at runtime to find the size for c-style array: sizeof(array)/sizeof(array[0])</p>
			</section>
			
			<section class="box">
				<h2>std::vector []</h2>
				<p>Use a vector if over a c-style array.</p>
<pre>
#include &lt;vector&gt;
using std::vector;
vector&lt;Dog&gt; dogVec;
dogVec.reserve(10)	//make room for 10 dogs
Dog d;
array.push_back(d);	//add, when full, array will grow
array[0].bark();
</pre>
				<p>Push object through method into vector</p>
<pre>
//in a method
Dog * dPtr;
Dog d("tom");
dPtr = &d;
add(dPtr);

void add(Dog * d){
	dogVec.push_back(*d);
}
</pre>
				<p>Multi vector</p>
<pre>
vector< vector<int> > a;

//iteration
for( int i(0); i &lt; a.size(); i++ )
	for( int j(0); j &lt; a[i].size(); j++ )
		a[i][j];
		
//accessing 2,2
a[2][2];

//size of first row
a[0].size();

//number of rows
a.size();

//passing to functions
int foo( vector&lt;vector&lt;int&gt;&gt; a)
{ return a[0][0]; }
</pre>
			</section>
			
			<section class="box">
				<h2>Char Array</h2>
				<p>Use only the c-style string (aka char array) when needed, otherwise, use std:string.</p>
				<p>When you pass in any array as argument, it turns into a pointer</p>
				<p>In c++, you cannot return a char array, but you can return a char pointer</p>
				<p>You have to keep track of on your own the size of the array into a variable, you cannot
				find the size of the array at runtime in c++. Hence string or vector was created which is easier to get the size.</p>
<pre>
//any values in [] is ignored
void mod(char msg[]){
	
}
//the arg is aka below which below is prefer
char* mod(char * const msg){
   return msg;
}
//the best way to return char array
void mod(char * msg){
   char str[10];
   //do something ...
   strcpy(msg, str);
}
</pre>
				<p>So you want to create a char array, pass into function, function modifies it through pointer. You don't actually return char array</p>
			</section>
			
			<section class="box">
				<h2>Single Array</h2>
				<p>You you initate</p>
<pre>
//3 size
int arr[3];
arr[0] = 33;
arr[1] = 44;

//method
void doArr(int arr[]){
	arr[0] = 3;
}
</pre>
				<p>You can use pointers</p>
			</section>
			
			<section class="box">
				<h2>Multi-dimensional arrays</h2>
				<p><a href="http://www.dreamincode.net/forums/topic/144007-multidimensional-arrays/">Aka 2d arrays or more</a></p>
				<p>You do not need to define the row in a method, just col. If you do, then you limit the method to only handle 3x3 arrays</p>
<pre>
//create 3x3
int a[3][3];
//access
a[3][2];
//only need to pass col
int foo(int a[][3]){
  return a[1][1];
}
</pre>
				<p>How to know size of array, you need to know rows or col</p>
				<p>Multi array pointers</p>
				<p>First we declare an array of integer pointers to integer pointers</p>
<pre>
int **a = new int*[height];
</pre>
				<p>Then loop and assign pointers to all pointers in the array</p>
<pre>
for( int i(0); i < height; i++ ){
  a[i] = new int[width];
 }
</pre>
				<p>Use neseted loop to access 2d arrays</p>
				<p>3d or bigger arrays</p>
<pre>
int a[2][2][2];
//use triple loop to access
for...
 for..
  for..
   a[i][j][k];
//method
int foo(int d[][2][2]){
  return d[1][1][1];
}
</pre>
				<p>3d array pointers, visit the multi array link above</p>
<pre>
int ***a = new int**[Dim1];

for( int i(0); i < Dim1; i++ ) 
	a[i] = new int*[Dim2];

for( int i(0); i < Dim1; i++ )
	for( int j(0); j < Dim2; j++ )
		a[i][j] = new int[Dim3];

</pre>
			</section>
			
		</section>
		
		<section>
		
		</section>
		
		<section>
			<h1>Help Links</h1>
			<ul>
				<li><a href="http://www.cplusplus.com/doc/tutorial/arrays/">
				CPP tutorials</a></li>
				<li><a target="_blank" href="http://cslibrary.stanford.edu/102/PointersAndMemory.pdf">Pointers</a></li>
			</ul>
		</section>
		
	</section>

</div>

</body>
</html>